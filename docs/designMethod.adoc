== Proceso de Diseño Arquitectónico

El diseño de la arquitectura del Sistema de Gestión Hotelera fue un proceso sistemático y racional, guiado por la metodología **Attribute-Driven Design (ADD)** y complementado por el proceso de especificación **Component-Based Software Engineering (CBSE)** de Cheesman & Daniels. Este enfoque aseguró que cada decisión arquitectónica respondiera directamente a los impulsores de negocio y a los requisitos de calidad críticos (Quality Attributes Scenarios - QAS), evitando cualquier arbitrio y garantizando la construcción de una solución robusta y alineada con los objetivos estratégicos.

=== Attribute-Driven Design (ADD): Diseño Guiado por Atributos de Calidad

ADD es un método iterativo que enfoca el diseño arquitectónico en la satisfacción de los requisitos de calidad del sistema. En lugar de comenzar con componentes o módulos, ADD arranca con los impulsores arquitectónicos clave, que para nuestro sistema son los atributos de calidad (Confiabilidad, Disponibilidad, Rendimiento, etc.) y sus escenarios específicos (QAS) identificados en el documento de Impulsores Arquitectónicos.

==== Backlog de Impulsores (Drivers Arquitectónicos)

El primer paso consistió en formalizar y priorizar el backlog de impulsores, que son los requisitos de calidad que el sistema debe satisfacer. Estos se extrajeron directamente de las preocupaciones de los stakeholders y los objetivos de negocio:

* **Confiabilidad:** Evitar dobles reservas y dobles cobros (tasa de incidentes del 0%). Idempotencia en transacciones de pago.
* **Disponibilidad:** Operación 24/7. Recuperación de fallos de la base de datos principal en menos de 5 minutos.
* **Rendimiento:**
** Consultas de disponibilidad: 500 req/s, con una latencia P95 <= 500ms.
** Confirmaciones de reserva: Ráfagas de 10 req/s, con una latencia P95 <= 2.5s.
* **Usabilidad:**
** Check-in para recepcionista novato operable de forma autónoma tras 10 minutos de instrucción.
** Flujo de reserva para huésped en menos de 5 pasos.
* **Seguridad:** Control de acceso basado en roles y prevención de acceso no autorizado.
* **Trazabilidad:** Registro detallado de todas las transacciones para permitir auditorías completas (CU-34).

Este backlog fue la guía inquebrantable para cada decisión arquitectónica tomada.

==== Iteraciones de Diseño y Decisiones Arquitectónicas

El diseño se abordó a través de múltiples iteraciones, cada una enfocada en satisfacer uno o más impulsores del backlog.

===== Iteración 1: Abordando Confiabilidad y Trazabilidad
* **Objetivo de la Iteración:** Garantizar la integridad transaccional para eliminar el riesgo de dobles reservas y dobles cobros (drivers CF-01, CF-02) y establecer un mecanismo robusto para la auditoría de operaciones (driver CRN-5).
* **Decisiones Tomadas (Tácticas/Patrones):**
** **Manejo de Concurrencia (Bloqueo Optimista):** Para evitar dobles reservas (CF-01), se implementó un mecanismo de bloqueo optimista en la gestión de disponibilidad.
** **Idempotencia en Pagos:** Para evitar dobles cobros (CF-02), se implementó una lógica a nivel de servicio de pagos para que una solicitud repetida solo resulte en una única transacción.
** **Transacciones Atómicas (ACID):** Apoyado en la restricción (CON-1) de usar un RDBMS, las operaciones críticas se envuelven en transacciones atómicas para garantizar la consistencia.
* **Drivers Atendidos:** Confiabilidad (totalmente), Trazabilidad (parcialmente).
* **Criterio de Suficiencia:** Las tácticas están diseñadas para cumplir la meta de 0% de incidentes de dobles reservas/cobros.

===== Iteración 2: Abordando Disponibilidad y Rendimiento en Lecturas
* **Objetivo de la Iteración:** Asegurar la operación continua del sistema (driver DA-01) y optimizar el rendimiento de las consultas de disponibilidad.
* **Decisiones Tomadas (Tácticas/Patrones):**
** **Replicación de Base de Datos:** Para la alta disponibilidad (DA-01), se implementó una replicación activa-pasiva del RDBMS para cumplir el objetivo de recuperación en menos de 5 minutos.
** **Patrón CQRS (Command Query Responsibility Segregation):** Para optimizar el rendimiento de las 500 consultas/segundo, se adoptó el patrón CQRS, separando los modelos de escritura de los de lectura.
* **Drivers Atendidos:** Disponibilidad (totalmente), Rendimiento (consultas totalmente).
* **Criterio de Suficiencia:** La replicación garantiza el RTO de < 5 minutos. CQRS está diseñado para cumplir la meta de 500 req/s y P95 <= 500ms.

===== Iteración 3: Abordando Rendimiento en Escrituras y Usabilidad
* **Objetivo de la Iteración:** Optimizar el rendimiento de las confirmaciones de reserva (driver RE-02) y mejorar la usabilidad.
* **Decisiones Tomadas (Tácticas/Patrones):**
** **Procesamiento Asíncrono (Colas de Mensajes):** Para manejar las 10 confirmaciones/segundo (RE-02), las tareas post-pago se gestionan de forma asíncrona.
** **Arquitectura en Capas y API Orientada a Tareas:** Se definió una Arquitectura en Capas con una API REST orientada a tareas (ej. `POST /check-in`) para simplificar la lógica del cliente.
* **Drivers Atendidos:** Rendimiento (confirmaciones totalmente), Usabilidad (bases del diseño).
* **Criterio de Suficiencia:** El procesamiento asíncrono está dimensionado para la meta de 10 req/s. El diseño de la API está alineado con los objetivos de simplicidad.

=== CBSE: Proceso de Especificación Basado en Componentes

Paralelamente al enfoque de ADD, se utilizó el proceso de especificación de CBSE para traducir los requisitos en una estructura de software concreta y bien definida.

==== Identificación: De Casos de Uso al Modelo de Conceptos

El primer paso fue realizar un análisis del dominio a partir de los **34 casos de uso** definidos (CU-01 a CU-34). Se identificaron los conceptos clave del negocio, que se formalizaron en el **Modelo de Conceptos de Negocio**.

==== Interacción: Refinamiento de Operaciones e Interfaces

Se analizaron las interacciones para los casos de uso críticos. El flujo de **Confirmación de Reserva (CU-02 y CU-03)** permitió definir las operaciones necesarias entre las capas para refinar las responsabilidades de cada componente.

==== Especificación: Definición de Interfaces y Contratos de Componentes

El último paso consistió en formalizar la estructura y los contratos de los componentes en la **Vista Lógica**. La arquitectura se especificó como un sistema en **4 capas (Presentación, Aplicación, Dominio, Infraestructura)**, donde cada capa es un componente lógico con responsabilidades y restricciones claras.
