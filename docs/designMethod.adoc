== 4.1 Método de Diseño

El diseño de la arquitectura para el Sistema de Gestión Hotelera no fue un acto arbitrario, sino un proceso sistemático y racional enfocado en satisfacer las necesidades críticas del negocio. Para lograr esto, se implementó un enfoque metodológico dual:

* *Attribute-Driven Design (ADD):* Se utilizó para derivar la arquitectura de alto nivel (vistas, patrones y tácticas) directamente desde los impulsores arquitectónicos (ASRs), asegurando que la estructura responda a los requisitos de calidad más críticos.
* *Component-Based Software Engineering (CBSE) (Cheesman & Daniels):* Se empleó como el proceso formal de especificación para traducir la arquitectura de alto nivel en un diseño detallado y contractual de componentes e interfaces, garantizando la coherencia y la correcta implementación.

Este documento explica cómo se aplicaron ambos métodos de manera secuencial e iterativa.

=== 1. Attribute-Driven Design (ADD): Derivando la Arquitectura

ADD es un método iterativo que enfoca el diseño en la satisfacción de los atributos de calidad. En lugar de comenzar con componentes, ADD arranca con los impulsores arquitectónicos priorizados.

==== 1.1. Backlog de Impulsores (Drivers Arquitectónicos)

El primer paso consistió en formalizar el backlog de impulsores, extraídos de los objetivos de negocio y los escenarios de atributos de calidad (QAS). Estos se priorizaron en función de su impacto crítico en el negocio:

* *Confiabilidad (Driver Principal):* Evitar dobles reservas (CF-01) y dobles cobros (CF-02) con una tasa de incidentes del 0%. Idempotencia en transacciones de pago.
* *Disponibilidad:* Operación 24/7. Recuperación de fallos de la base de datos principal en < 5 minutos (DA-01).
* *Rendimento:*
** Consultas de disponibilidad: Latencia P95 ≤ 500ms bajo 300 QPS.
** Confirmaciones de reserva: Picos de 10 TPS, con P95 ≤ 2.5s (RE-02).
* *Usabilidad:* Check-in para recepcionista novato autónomo tras 10 minutos de instrucción.
* *Restricciones:* Uso obligatorio de RDBMS para transacciones (CON-1), pago completo al reservar (CON-3) e integración con pasarela de pago externa (CON-5).
* *Preocupaciones:* Trazabilidad y Observabilidad (CRN-5).

Este backlog fue la guía inquebrantable para cada decisión de diseño.

==== 1.2. Iteraciones de Diseño y Decisiones Arquitectónicas (ADD)

El diseño se abordó en iteraciones, cada una enfocada en satisfacer un conjunto de impulsores del backlog mediante tácticas y patrones específicos.

===== Iteración 1: Abordando Confiabilidad y Trazabilidad

*Objetivo de la Iteración:* Garantizar la integridad transaccional (evitar dobles reservas y dobles cobros) y establecer la base para la auditoría (CRN-5).

*Decisiones Tomadas (Tácticas/Patrones):*
* *Aislamiento del Dominio (Patrón: Domain-Driven Design):* Se decidió aislar toda la lógica de negocio crítica en una Capa de Dominio explícita. Las reglas para verificar disponibilidad, aplicar overbooking (CON-4) y gestionar la concurrencia (CF-01) residirán aquí, independientes de la infraestructura.
* *Manejo de Concurrencia (Táctica: Bloqueo Pesimista/Optimista):* Para el escenario CF-01, donde 50 usuarios compiten por la última habitación, se seleccionó el uso de bloqueo pesimista a nivel de base de datos (garantizado por el RDBMS) sobre el inventario al momento de la escritura. Para lecturas, se usará bloqueo optimista.
* *Idempotencia en Pagos (Táctica: ID de Idempotencia):* Para satisfacer CF-02 y evitar dobles cobros, cada solicitud de pago al PaymentGatewayClient debe incluir un Idempotency-Key único. El servicio de pagos usará esta clave para garantizar que una solicitud repetida solo se procese una vez.
* *Trazabilidad (Táctica: Logging/Auditoría):* Se estableció que todas las operaciones que modifican el estado (reserva, pago, check-in) deben generar un registro de auditoría (CRN-5), implementado en la Capa de Infraestructura (Logging).

*Drivers Atendidos:* Confiabilidad (CF-01, CF-02), Trazabilidad (CRN-5), Restricción (CON-1).

*Criterio de "Suficiente":* Las tácticas de bloqueo e idempotencia están diseñadas para cumplir la meta de 0% de incidentes. El aislamiento del dominio permite pruebas unitarias de estas reglas críticas.

===== Iteración 2: Abordando Disponibilidad y Rendimiento (Lectura)

*Objetivo de la Iteración:* Asegurar la operación 24/7 (DA-01) y optimizar el alto volumen de consultas de disponibilidad (300 QPS).

*Decisiones Tomadas (Tácticas/Patrones):*
* *Replicación de Base de Datos (Táctica: Redundancia):* Para satisfacer DA-01, la base de datos RDBMS principal (escritura) se replicará a una o más bases de datos secundarias (lectura). Se implementará un mecanismo de failover automático.
* *Separación de Responsabilidades (Patrón: CQRS):* Para manejar la alta carga de lecturas (300 QPS) sin degradar el rendimiento transaccional de las reservas (10 TPS), se adoptó un patrón CQRS (Command Query Responsibility Segregation). Las escrituras (Comandos) irán al RDBMS principal, mientras que las consultas de disponibilidad (Queries) se dirigirán a las réplicas de lectura optimizadas.
* *Caching (Táctica: Caché Distribuido):* Para reducir la latencia de las consultas de disponibilidad (P95 ≤ 500ms) y disminuir la carga en las réplicas de BD, se implementará un caché distribuido (ej. Redis) en la Capa de Infraestructura.

*Drivers Atendidos:* Disponibilidad (DA-01), Rendimiento (Consultas).

*Criterio de "Suficiente":* La replicación y el failover están diseñados para cumplir el RTO de < 5 minutos. CQRS y el caching están dimensionados para manejar 300 QPS con latencia P95 < 500ms.

===== Iteración 3: Abordando Rendimiento (Escritura) y Usabilidad

*Objetivo de la Iteración:* Optimizar el flujo de confirmación de reserva (RE-02, P95 ≤ 2.5s) y sentar las bases para una alta usabilidad en recepción.

*Decisiones Tomadas (Tácticas/Patrones):*
* *Orquestación de Casos de Uso (Táctica: Capa de Aplicación):* Se definió una Capa de Aplicación explícita cuya única responsabilidad es orquestar los casos de uso (ej. BookingApplicationService). Esto satisface la Usabilidad al mantener los controladores (BookingController) simples y delgados.
* *Procesamiento Asíncrono (Táctica: Colas de Mensajes):* El escenario RE-02 (P95 ≤ 2.5s) es difícil de cumplir si incluye la comunicación síncrona con la pasarela de pago y el envío de correos. Se decidió que el ApplicationService solo realizará las operaciones críticas (verificar inventario, procesar pago). Tareas no críticas (ej. enviar email de confirmación, notificar a auditoría) se manejarán de forma asíncrona mediante una cola de mensajes (Infraestructura).

*Drivers Atendidos:* Rendimiento (RE-02), Usabilidad.

*Criterio de "Suficiente":* El procesamiento asíncrono libera el hilo de solicitud rápidamente, permitiendo que la respuesta al usuario (P95) se mantenga bajo los 2.5 segundos, incluso si las tareas en segundo plano toman más tiempo.

=== 2. CBSE (Cheesman & Daniels): El Proceso de Especificación

Las iteraciones ADD definieron la arquitectura de alto nivel (Capas, DDD, CQRS). Sin embargo, para que esta arquitectura sea implementable y cumpla con los drivers de confiabilidad, necesitamos un proceso riguroso para especificar el comportamiento de sus partes. Aquí es donde se aplica el proceso CBSE de Cheesman & Daniels, que sigue tres fases: Identificación, Interacción y Especificación.

==== 2.1. Fase 1: Identificación de Componentes

El objetivo de esta fase es identificar las especificaciones de componentes (<<comp spec>>) que el sistema necesita.

*Entradas:* Las entradas principales para esta fase fueron los Casos de Uso (CU-01 a CU-34) y el Modelo de Conceptos de Negocio (implícito en la Capa de Dominio de la Vista Lógica).

*Proceso:*
* *Identificación de Interfaces:* Analizamos los casos de uso para identificar los "puntos de contacto" del sistema. Los actores (Huésped, Recepcionista, Administrador) definen las interfaces de presentación. Los sistemas externos (Pasarela de Pago) definen interfaces de infraestructura.
* *Agrupación de Funcionalidad:* Agrupamos los casos de uso por cohesión funcional. Por ejemplo:
** CU-01 (Consultar disponibilidad), CU-02 (Reservar), CU-03 (Pagar), CU-04 (Cancelar) se agruparon en la necesidad de un componente *Booking*.
** CU-08 (Check-in), CU-07 (Check-out), CU-09 (Cambiar habitación) se agruparon en un componente *StayManagement*.
** CU-17 (Registrar tipo habitación), CU-21 (Registrar habitación), CU-32 (Gestionar overbooking) se agruparon en un componente *Inventory*.
* *Modelo de Conceptos:* El modelo de dominio (Reservation, RoomType, Hotel) sirvió para definir los datos que estos componentes gestionarían.

*Salida:* Un primer borrador de las Especificaciones de Componentes (<<comp spec>>) y sus interfaces (<<interface type>>) necesarias para satisfacer los requisitos funcionales.

==== 2.2. Fase 2: Interacción de Componentes

El objetivo de esta fase es refinar las interfaces y componentes modelando cómo colaboran para realizar las operaciones del sistema.

*Entradas:* Los Casos de Uso detallados y el borrador de componentes de la Fase 1.

*Proceso:* Se utilizaron Diagramas de Comunicación (o Secuencia) de UML para modelar el flujo de las operaciones críticas del sistema, trazándolas contra las capas definidas en el ADD.

===== Ejemplo: Flujo "Confirmar Reserva" (CU-02 + CU-03)

Modelamos esta interacción, lo cual está reflejado en el Diagrama de Objetos de la Vista Lógica.
. Un *BookingController* (Presentación) recibe la llamada.
. Invoca a *BookingApplicationService* (Aplicación).
. Este servicio requiere interfaces de dominio e infraestructura.
. Llama a *IInventoryRepository.GetRoomType()* (Infraestructura) para obtener el objeto *RoomType* (Dominio).
. Llama a *RoomType.reserveRoom()* (Dominio), donde reside la lógica de concurrencia (CF-01).
. Llama a *IPaymentGateway.ProcessPayment()* (Infraestructura), donde se aplica la idempotencia (CF-02).
. Llama a *IReservationRepository.Save()* (Infraestructura) para persistir la reserva (CON-1).

*Salida:* Este proceso validó las decisiones de las iteraciones de ADD (ej. la necesidad de una capa de aplicación para orquestar) y refinó las firmas de las operaciones en cada interfaz (<<interface type>>).

==== 2.3. Fase 3: Especificación de Componentes

Esta es la fase final y más detallada, donde se definen los "contratos" formales que garantizan la confiabilidad del sistema.

*Entradas:* Las interfaces y componentes refinados de la Fase 2.

*Proceso:* Siguiendo el rigor de Cheesman & Daniels, se especificaron los contratos de las interfaces clave (<<interface type>>).

*Firmas de Operación:* Se definieron los parámetros de entrada y salida (ej. *ProcessPayment(RequestDTO, IdempotencyKey)*).

*Precondiciones:* Obligaciones que el cliente (invocador) debe cumplir.
*Ejemplo:* Para *IInventory.reserveRoom(roomTypeID, dates)*:
----
pre: roomTypeID debe existir.
pre: dates debe ser un rango válido.
----

*Postcondiciones:* Garantías que el proveedor (componente) ofrece si las precondiciones se cumplen. Fundamental para la Confiabilidad (CF-01).
*Ejemplo:* Para *IInventory.reserveRoom(roomTypeID, dates)*:
----
post: El inventario disponible para (roomTypeID, dates) se ha decrementado en 1.
post: Si no hay inventario (incluyendo overbooking), se lanza una excepción "NoAvailabilityException".
----

*Invariantes:* Reglas que deben ser siempre verdaderas.
*Ejemplo:* Para *InventoryComponent*:
----
inv: El número de habitaciones reservadas para un (roomTypeID, date) nunca debe exceder el (inventario físico + política de overbooking).
----

*Salida:* Un conjunto de Especificaciones de Componentes (<<comp spec>>) e Interfaces (<<interface type>>) con contratos formales. Estos contratos son la garantía de diseño de que los ASRs críticos, como la Confiabilidad (CF-01, CF-02), se cumplen, no por casualidad, sino por un diseño contractual explícito.
